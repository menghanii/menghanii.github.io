---
title: Week5_1 Graph 기초
categories: [boostcamp]
tags: [부스트캠프, NLP]
math: true
comments: true
---

\- 이 강의정리본은 KAIST 신기정 교수님의 강의를 정리한 것임을 밝힙니다.\-

### 그래프란 무엇이고 왜 중요할까?

- 그래프 : 정점 - 간선 집합으로 이루어진 수학적 구조.

  - 정점(vertex, node) : 점 혹은 원으로 그려짐.
  - 간선(edge, link) : 정점을 연결하는 선.
  - 모든 정점 쌍이 반드시 간선으로 연결되는 것은 아님.

  ![image-20210222154809841](/assets/img/post-images/image-20210222154809841.png){: width="80%"}

- 그래프가 왜 중요할까?
  - 우리 주변에는 많은 **복잡계(complex system)**가 있다.
  - 사회, 통신시스템, 정보, 지식, 뇌, 신체 -> 모두 복잡계로 생각할 수 있다.
  - 복잡계가 가진 공통적인 특성 : 구성 요소 간의 복잡한 **상호작용**. 이것이 복잡계를 복잡하게 만드는 요소가 되는 것이다.
  - 이런 복잡계는 어떻게 표현해야할까? 바로 Graph이다. 
    - graph는 복잡계를 효과적으로 표현하기 위한 언어이다.
    - ex) Social Network : 사용자들을 그래프의 정점으로, 두 계정 사이의 친구관계를 간선으로 나타낼 수 있다. 
    - ex2) 전자상거래 구매내역 : 두 종류의 정점이 존재한다. 사용자와 판매물건들. 특정 사용자가 특정 물건을 구매한 적이 있으면 간선으로 연결하고, 구매하지 않았으면 간선으로 연결되지 X.
    - ex3) 인터넷 : 라우터들 간의 상호작용. 웹도 웹페이지들 간의 상호작용. 위키피디아도 어떤 사용자가 어떤 문서를 보았는지에 따라 그래프로 나타낼 수 있다.
    - ex4) 뇌 : 뉴런 간의 연결. 
    - ex5) 지식 그래프
    - ex6) 화학 분자.. 등 굉장히 다양한 예들이 많다.
- 복잡계를 이해하고, 정확한 예측을 하기 위해서는 복잡계 이면에 있는 그래프에 대한 이해가 반드시 필요하다.
- 왜 그래프를 공부해야할까?
  - 복잡계가 존재하는 수많은 분야에 활용할 수 있기 때문이다.
  - 전산/물리/생물/화학/사회과학 등이 그 예이다.

### 그래프 관련 인공지능 문제

- 정점분류 문제(node classification) : 정점이 여러 유형을 가진 경우 각 정점의 유형을 추측하는 문제.
  - ex) 트위터에서의 공유관계를 분석하여, 각 사용자의 정치적 성향을 알 수 있을까?
    - ![image-20210222155554144](/assets/img/post-images/image-20210222155554144.png){: width="80%"}
    - 같은 색의 점이 같은 정치적 성향을 가지는 사용자들
    - 트위터에서의 공유 관계(Retweet) : 어떤 계정이 어떤 계정의 글을 rt했는지를 간선 관계로 표시하는 것이 공유관계 그래프라고 생각할 수 있다.
    - 같은 정치적 성향을 가진 사람들끼리 좀 더 글을 많이 공유하는 것을 볼 수 있다.
    - 새로운 정점이 등장했을 떄, 혹은 정치적 성향을 모르는 정점이 등장했을 때, 어떤 글을 공유하냐에 따라 이 정점의 정치적 성향을 예측해볼 수 있다.
  - ex2) 단백질의 상호작용. 단백질의 상호작용을 분석하여 단백질의 역할을 알아낼 수 있을까?
    - ![image-20210222155717627](/assets/img/post-images/image-20210222155717627.png){: width="80%"}
    - 각 단백질이 어떤 단백질과 상호작용하는지를 보고 특정 단백질의 역할을 추측할 수 있다.
- 연결 예측 문제(Link Prediction) : 거시적/ 미시적 관점에서 살펴볼 수 있다.
  - 거시적 : 주어진 그래프가 어떻게 성장할 지를 예측하는 문제.
    - ex) FaceBook Social Network 는 앞으로 어떻게 진화할까? 성장? 둔화?
  - 미시적 : 추천 문제. 각 정점이 앞으로 어떤 정점과 연결될 지를 예측하는 문제.
    - 각자에게 필요한 물건은 무엇일까? 어떤 물건을 구매해야 만족도가 높을까?
- 군집 분석(Community Detection) 문제
  - 연결 관계로부터 사회적 무리(Social circle)를 찾아낼 수 있을까?
  - ![image-20210222155955312](/assets/img/post-images/image-20210222155955312.png){: width="80%"}
  - 군집을 찾아냄으로써 의미있는 사회적 무리를 찾아낼 수 있다.
  - 즉, 그래프가 주어졌을 때, 자동적으로 빽빽하게 무리지어 있는 군집을 찾아내는 알고리즘.
- 랭킹 및 정보검색 문제 (Ranking and Information Retrieval)
  - 웹이라는 거대한 그래프로부터 어떻게 중요한 웹페이지를 찾아낼 수 있을까?
- 정보 전파(Information Cascading) 및 바이럴 마케팅(Viral Marketing) 문제
  - 정보는 네트워크를 통해 어떻게 전달될까? 어떻게 정보 전달을 최대화할 수 있을까?

### 그래프 관련 필 수 기초 개념

#### 그래프의 유형 및 분류

- 첫 번째 기준 : 간선의 방향이 있는지/없는지
  - Undirected Graph
    - 협업 관계 그래프 : 같은 팀의 일원으로서 관계를 맺음. 두 사람 모두 팀원이라는 관계로 맺는 것이기 때문에 방향이 없음.
    - 페이스 북 친구 관계 : 친구를 맺을 경우, 서로 친구가 되기 때문. 팔로우관계와는 다르다.
  - Directed Graph 
    - 주체와 대상이 분리될 수 있는 경우
    - 인용 그래프(인용을 하는 논문 / 당하는 논문이 명확하게 구분되며, 그 관계가 대등하지 않음. 인용을 하는 쪽으로부터 받는쪽으로 화살표가 감.)
    -  트위터 팔로우 그래프(내가 트와이스 계정을 팔로우 할 수 있지만, 트와이스 계정은 나를 팔로우하지 않을 수 있다.)
- 두 번째 기준 : 간선에 가중치가 있는지/없는지
  - 가중치가 없는 그래프(Unweighted Graph)
    - 가중치가 의미가 없는 경우. 단순하게 나타내기 위한 그래프.
    - 웹 그래프 : 
    - 페이스북 친구 그래프 : 이 두 사람이 얼마나 많은 상호작용을 했는지가 중요하지 않다면, 가중치가 없는 그래프로 나타낼 수 있음. 이는 주관적인 것임. 상호작용이 중요해진다면 weighted graph로 나타낼 수도 있다.
  - 가중치가 있는 그래프(Weighted Graph)
    - 간선에 숫자들이 부여되어 있음.
    - 전화 그래프 : 어떤 사람 - 어떤 사람이 몇 번 전화를 주고 받았는지. 전화를 많이할수록 친밀한 관계이기 때문에, 숫자가 클수록 친밀도가 높음을 의미할 수도 있음.
    - 유사도 그래프
- 세 번째 기준 : 정점의 종류가 동질적인지/이질적인지에 따라 동종그래프(Unpartite Graph) 와 이종 그래프(Bipartite Graph)
  - 동종 그래프(Unpartite Graph) : 단일 종류의 정점을 가진다.
    - 웹 그래프 : 모든 정점들은 웹페이지라는 동일한 종류. 
    - 페이스북 친구 그래프 : 모든 정점이 페이스북 계정.
  - 이종 그래프(Bipartite Graph) : 두 종류의 정점을 가진다.
    - 특징 : **서로 다른 종류의 정점 사이에만 간선이 연결된다.** 즉, 사용자와 사용자, 물건과 물건은 연결될 수 없고, 사용자와 상품만이 연결될 수 있다.
    - 전자 상거래 구매 내역 : 사용자와 상품 정점을 가진다. 어떤 사용자가 어떤 상품을 구매했는지.
    - 영화 출연 그래프 : 배우와 영화 정점을 가진다. 어떤 배우가 어떤 영화에 출연했는지.
- ![image-20210222161247810](/assets/img/post-images/image-20210222161247810.png){: width="80%"}
- 이 전자상거래 구매내역은 어떤 유형의 그래프일까?
  - 첫 번째 기준에 의하면, 방향성이 없으므로 `Undirected Graph` (방향성을 부여할 수도 있지만, 어차피 모든 구매는 사용자 -> 상품으로 가는 것이므로 방향성을 추가함으로써 발생하는 복잡도에 비해 얻는 것이 없으므로 굳이 방향성을 나타낼 필요가 없다.)
  - 두 번째 기준에 의하면, 만족도로 별점이 매겨져 있으므로 `Weighted Graph`. 
  - 세 번째 기준에 의하면, 사용자와 물건 정점으로 구분되어 있으므로 `Bipartite Graph`.

#### 그래프 관련 필수 기초 개념

- 그래프는 정점 집합과 간선 집합으로 이루어진 수학적 구조.
- 정점들의 집합을 **V**, 간선들의 집합을 **E**, 그래프를 **G = (V, E)**로 적는다.
- 정점의 이웃(Neighbor)는 정점과 연결된 다른 정점을 의미한다.
  - ![image-20210222161711566](/assets/img/post-images/image-20210222161711566.png){: width="80%"}
  - 정점 **V**의 이웃들의 집합을 보통 $$N(v)$$ 혹은 $$N_v$$로 적는다.
  - 위 예시에서 $$N(1) = {2, 5}$$, $$N(2)={1, 3, 5}$$ 등으로 나타낼 수 있다.
- 방향성이 있는 그래프(Directed Graph)에서는 나가는 이웃과 들어오는 이웃을 구분한다.
  - ![image-20210222162026464](/assets/img/post-images/image-20210222162026464.png){: width="80%"}
  - 정점 v에서 간선이 나가는 이웃(Out-Neighbor)의 집합을 보통 $$N_{out}(v)$$ 라고 적으며
  - 정점 v로 간선이 들어오는 이웃(In-Neighbor)의 집합을 보통 $$N_{in}(v)$$라고 적는다.
  - 위 예시에서 $$N_{in}(5)={2, 4}$$이며, $$N_{out}(5)={1, 2}$$  이다.

### 그래프의 표현 및 저장

#### Python Library : NetworkX

- 그래프를 생성 ,변경, 시각화
- 그래프의 구조와 변화를 분석할 수 있음.
- [이 곳](https://network.org/documentation/stable/index.html)에서 자세한 정보를 확인할 수 있다.
- `Snap.py`라는 파이썬 라이브러리도 많이 사용된다.([요기](https://snap.stanford.edu/snappy/))
- 교수님의 개인적 소감 : networkx는 속도가 느리지만 편리, snappy는 사용은 불편하지만 속도가 빠름.
  - 두 라이브러리가 제공하는 기능은 공통적인 것도 많지만, 서로에게 없는 것도 있으므로 두 라이브러리를 모두 익히는 것이 도움이 될 것임.

#### 그래프의 표현

- library import

  ```python
  import networkx as nx
  import numpy as np
  import matplotlib.pyplot as plt
  ```

- 그래프 생성 및 초기화

  ```python
  print('##### Graph Init #####')
  G = nx.Graph() # 방향성 없는 그래프 초기화
  DiGraph = nx.DiGraph() # 방향성 있는 그래프 초기화
  ```

- 정점을 추가하고, 정점의 수를 세고, 목록을 반환

  ```python
  print('##### Add Node to Graph #####')
  print('# Add node 1')
  G.add_node(1) # 정점 1 추가
  print('Num of nodes in G:' + str(G.number_of_nodes())) # 정점 수 반환
  print('Graph : ' + str(G.nodes) + "\n") # 정점 목록 반환
  ```

- 더 많은 정점을 추가해보자.

  ```python
  print('##### Add Node 2 ~ 10')
  for i in range(1, 11):
      G.add_node(i)
  print('Num of nodes in G:' + str(G.number_of_nodes())) # 정점 수 반환
  print('Graph : ' + str(G.nodes) + "\n") # 정점 목록 반환
  ```

- 간선을 추가하고, 목록을 반환해보자.

  ```python
  print('##### Add Edge to Graph #####')
  print('# Add edge(1, 2)')
  G.add_edge(1, 2) # 정점 1과 2 사이에 간선 추가
  print('Graph : ' + str(G.edges) + '\n') # 간선의 목록을 반환
  ```

- 더 많은 간선을 추가해보자.

  ```python
  print('# Add edge(1, i) for i = 2~10')
  for i in range(2, 11):
  	G.add_edge(1, i) # 정점 1과 i 사이에 간선 추가
  print('Graph : ' + str(G.edges) + '\n') # 간선의 목록을 반환
  ```

- 그래프를 시각화해보자.

  ```python
  # 정점의 위치를 결정 : 정점의 위치를 임의로 결정하게 되면 굉장히 복잡해짐.
  # 간선들이 겹치지 않게 이쁘게 그려지기 위해서는 정점들의 위치를 신중하게 결정해야함.
  # 이 역할을 하는 것이 spring_layout 함수이다.
  pos = nx.spring_layout(G) 
  
  # 정점의 색과 크기를 지정하여 출력
  im = nx.draw_networkx_nodes(G, pos, node_color='red', node_size=100)
  
  # 간선 출력
  nx.draw_networkx_edges(G, pos)
  
  # 각 정점의 라벨을 출력(정점의 이름!)
  nx.draw_networkx_labels(G, pos, font_size=10, font_color='black')
  plt.show()
  ```

- ![image-20210222163535112](/assets/img/post-images/image-20210222163535112.png){: width="80%"}

#### 그래프의 저장

- ① 간선 리스트(edge list) : 그래프는 간선들의 리스트로 저장한다.
  - 각 간선은 해당 간선이 연결하는 두 정점들의 순서쌍(pair)으로 저장된다.
  - 무방향 그래프의 경우
  - ![image-20210222163714377](/assets/img/post-images/image-20210222163714377.png){: width="80%"}
  - 방향 그래프의 경우 : **(출발점, 도착점)** 순서로 저장된다.
  - ![image-20210222163806259](/assets/img/post-images/image-20210222163806259.png){: width="80%"}
    - 2번에서 5번으로, 5번에서 2번으로 가게 되면 (2, 5), (5, 2)가 모두 저장된다.
- 간선 리스트는 간단하게 그래프를 저장/표현할 수 있지만, 사용할 때 비효율적인 측면이 있다.
  
- 만약, 위의 방향성 그래프에서 3번 노드와 4번 노드가 관계가 있는지 확인하려고 한다면 간선리스트를 처음부터 훑어야 한다. 
  
- ② 인접리스트(adjacent list) : 각 정점의 이웃들을 리스트로 저장.

  - 무방향 그래프의 경우 - {1 : [2, 5], 2: [1, 3, 5], ...}
  - ![image-20210222164021013](/assets/img/post-images/image-20210222164021013.png){: width="80%"}
  - 방향 그래프의 경우 - 나가는 이웃과 들어오는 이웃들을 각각 리스트로 따로 저장.
  - ![image-20210222164118649](/assets/img/post-images/image-20210222164118649.png)
  - 인접리스트는 간선리스트에 비해 사용 시에 효율적인 측면이 있다.
    - 3번 정점에서 나가는 이웃을 살펴보고 싶을 때, 그래프의 간선들을 다 읽을 필요 없이 해당하는 부분만 읽을 수 있음.

- ③ 인접 행렬(Adjacent Matrix) : 행렬로 그래프를 표현하는 방법

- 정점 수 x 정점 수 크기의 행렬

- 무방향 그래프의 경우

  - $$i$$와 $$j$$ 사이에 간선이 **있는** 경우, 행렬의 $$i$$행 $$j$$열(및 $$j$$행 $$i$$열) 의 원소가 `1`
  - $$i$$와 $$j$$ 사이에 간선이 없는 경우, 행렬의 $$i$$행 $$j$$열(및 $$j$$행 $$i$$열) 의 원소가 `0`
  - ![image-20210222164446274](/assets/img/post-images/image-20210222164446274.png){: width="80%"}

- 방향 그래프의 경우

  - $$i$$에서 $$j$$ 로의 간선이 **있는** 경우, 행렬의 $$i$$행 $$j$$열의 원소가 `1`
  - $$i$$에서 $$j$$ 로의 간선이 **없는** 경우, 행렬의 $$i$$행 $$j$$열의 원소가 `0`
  - 즉, 방향 그래프의 경우와 달리 행렬이 대칭성을 띠지 않는다.
  - ![image-20210222164604043](/assets/img/post-images/image-20210222164604043.png){: width="80%"}
  - `1`에서 `2`로 가는 간선은 있지만, `2`에서 `1`로 가는 간선은 없기 때문에, `1행 2열`의 값은 `1`이지만, `2행1열`의 값은 `0`인 것을 볼 수 있다.

- `NetworkX`에서 그래프를 표현 및 저장해보자.

  - ① 간선리스트

    ```python
    nx.to_edgelist(G)
    ```

  - ② 인접리스트

    ```python
    nx.to_dict_of_lists(G)
    ```

  - ③ 인접행렬

    ```python
    nx.to_numpy_array(G) # 일반 행렬 형태로 저장
    nx.to_scipy_sparse_matrix(G) # 희소 행렬 형태로 저장
    ```

    - `일반 행렬`은 전체 원소를 저장하므로 $$정점수^2$$에 비례하는 저장 공간을 사용
    - `희소 행렬`은 0이 아닌 원소만을 저장하므로 간선 수에 비례하는 저장 공간을 사용
    - 만약 정점 수가 10만개, 간선 수가 100만개라면
      - 일반행렬로 나타냈을 때 $$100000^2$$ = 100억개
      - 희소행렬로 나타냈을 때 100만개 를 사용하게 됨.
    - 희소행렬이 저장공간을 많이 아낄 수 있다. 
      - But 행렬 대부분의 원소가 0이 아닌 경우, 일반행렬의 속도가 훨씬 빠르다!

 ### 정리

1. 그래프란 무엇이고 왜 중요할까?
   1. 그래프는 정점 집합과 간선 집합으로 이루어진 수학적 구조
   2. 복잡계를 표현하고 분석하기 위한 언어
2. 그래프 관련 인공지능 문제
   1. 정점 분류, 연결 예측, 추천, 군집 분석, 랭킹, 정보 검색, 정보 전파, 바이럴 마케팅 등
3. 그래프 관련 필수 기초 개념
   1. 방향성이 있는/없는 그래프 ,가중치가 있는/없는 그래프, 동종/이종 그래프
   2. 나가는/들어가는 이웃
4. 그래프의 표현 및 저장
   1. NetworkX, snappy
   2. 간선리스트, 인접리스트, 인접행렬

