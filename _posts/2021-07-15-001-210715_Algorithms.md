---
title : "[Python] Programmers - 짝지어 제거하기 : Stack"
tag: [알고리즘]
categories: [algorithms]
math : true
comments: true
---

### 문제링크

https://programmers.co.kr/learn/courses/30/lessons/12973

### 문제설명

```
짝지어 제거하기는, 알파벳 소문자로 이루어진 문자열을 가지고 시작합니다. 
먼저 문자열에서 같은 알파벳이 2개 붙어 있는 짝을 찾습니다. 
그다음, 그 둘을 제거한 뒤, 앞뒤로 문자열을 이어 붙입니다. 
이 과정을 반복해서 문자열을 모두 제거한다면 짝지어 제거하기가 종료됩니다. 
문자열 S가 주어졌을 때, 짝지어 제거하기를 성공적으로 수행할 수 있는지 반환하는 함수를 완성해 주세요. 
성공적으로 수행할 수 있으면 1을, 아닐 경우 0을 리턴해주면 됩니다.

예를 들어, 문자열 S = baabaa 라면

b aa baa → bb aa → aa →

의 순서로 문자열을 모두 제거할 수 있으므로 1을 반환합니다.

제한사항
문자열의 길이 : 1,000,000이하의 자연수
문자열은 모두 소문자로 이루어져 있습니다.
```

### 문제풀이

#### 첫 번째 풀이 : 정규표현식(Regex)을 사용한 풀이

처음 생각났던 방법은, 같은 문자가 두 번 반복되는 모든 경우를 찾아서 `re.sub()`를 통해 빈 문자열(`''`)로 치환해주는 방식이다. 더 이상 두 번 반복되는 문자가 없을 때까지 `re.sub()`를 반복한 후, `S`의 길이가 0이라면 짝지어 제거하기가 완료된 것이므로 `1`을, `S`의 길이가 0이 아니라면 짝지어 제거하기가 불가능한 상황이므로 `0`을 반환한다.

정확도 측면에서는 맞는 방식이지만, 이렇게 하면 효율성 테스트에 가지도 못하고 정확성 테스트에서 **시간 초과**가 난다. 문자열이 길수록 짝지어 제거하기가 끝날 때까지 `re.sub()`를 계속 반복해야 하므로 시간적으로 오래걸릴 것이 뻔하기 때문이다.

다만 배운 것이 있다면 정규표현식에서의 `역참조(back reference)`이다. 역참조는 하위표현식으로 묶인 그룹을 참조하여 동일한 패턴을 갖다 쓸 수 있게 한 방법이다. 즉, `같은 문자 반복`, `같은 표현 반복` 등을 표현할 때 필히 쓰여야 한다. 하위표현식으로 묶인 그룹에 대해 `\1`, `\2`, ... 등으로 참조한다. 참고로 번호는 `n`번째 하위표현식을 참조하고 있음을 의미한다. 

이 문제에서는 한 가지 문자가 두 번 반복되는 경우를 찾아야 하는데, 나는 `r'([a-z])\1'`로 썼다. 알파벳 소문자 중 하나에 대해, 이를 하위표현식으로 묶고 `\1`을 통해 역참조를 함으로써 알파벳 소문자가 두 번 반복되는 경우를 의미하게 되었다. 여기서 `r`은 `raw-string`으로서, 백슬래쉬(`\`)를 escape 문자로 인식하지 않고 백슬래쉬 그대로 인식하게끔 하는 역할을 수행한다. `r`을 써줘야만 `\1`이 역참조로 제대로 인식된다.

효율성에서 막힌 코드이지만 그래도 아까우니까 한 번 써본다..

```python
# using Regex - high time complexity
import re
def solution(s):
    answer = 0
    pattern = re.compile(r'([a-z])\1') # back reference
    while len(re.findall(pattern, s)) != 0:
        s = re.sub(pattern, '', s)
    
    if len(s) != 0:
        return answer
    else:
        return 1
```



#### 두 번째 풀이 : 스택(Stack)을 사용한 풀이

Time Complexity를 `O(N)`으로 맞춰줄 수는 없을까? 하다가 생각난 게 `Stack`이었다. 이전에  LeetCode에서 **Valid Parentheses**(https://leetcode.com/problems/valid-parentheses/)라는 문제를 푼 적이 있었는데, 이 문제랑 거의 유사하다고 생각했다. Valid Parentheses에서는 열고 닫는 괄호가, 이 문제에서는 같은 문자가 반복되는 경우로 치환하여 생각하면 된다.

`Stack`은 `LIFO(Last In First Out)` 구조임을 이용한 풀이이다. `Stack`에 가장 최근에 들어간(Last In) 알파벳(x)과, `S`에서 뽑은 그 다음 문자(y)를 비교한다. 만약 두 문자열이 같다면 그대로 없애주고(`continue`), 두 문자열이 다르다면 다시 `Stack`에 `x`, `y`를 순서대로 넣어준다. 이걸 `S`의 길이가 0이 될 때까지 반복한다. 최종적으로 `Stack`에 아무것도 남아있지 않다면 짝지어 제거하기가 완료된 것이고, `Stack`에 남아있는 것이 있다면 짝지어 제거하기가 불가능한 상황이 된다.

이렇게 풀게 되면 `S`에서 모든 문자열을 뽑는 순간 끝나므로 시간 복잡도 `O(N)`으로 끝낼 수 있다. 따라서 정확도/효율성 테스트 모두 통과할 수 있었다.

```python
# using stack
def solution(s):
    answer = 0
    s = list(s)
    stack = [s.pop()]
    while len(s) != 0:
        a = s.pop()
        if len(stack) == 0:
            stack.append(a)
            continue
        b = stack.pop()
        if a != b:
            stack.append(b)
            stack.append(a)
    if len(stack) == 0:
        return 1
    return answer
```



### 추가 고찰

- `pop()` 과 `pop(0)`은 시간복잡도 측면에 있어서 어떤 차이가 날까? 
  - 위 코드에서 `s`에서는 마지막 문자를 먼저 뺴든, 첫 번째 문자를 먼저 빼든 정답은 달라지지 않는다.
  - 따라서 첫 번째 문자를 빼려고 `pop(0)`을 쓰면 효율성에서 갑자기 시간이 엄청나게 증가한다. 
  - 첫 번째 원소를 뽑나, 마지막 원소를 뽑나 걸리는 시간은 똑같지 않은가? 하고 생각했지만, 갓택오버플로를 찾아보니 그렇지 않았다. 왜냐면..

------------------------

![image-20210715022950436](/assets/img/post-images/image-20210715022950436.png){: width="100%"}

------------------------

- 리스트에서 마지막 원소를 `pop()`하게 되면 그 놈만 빼고 아무런 일도 일어나지 않는다. 따라서 `O(1)`이 걸린다.

- 하지만 첫 번째 원소를 `pop(0)`하게 되면 그 놈을 빼고, **나머지 모든 원소들을 돌면서** 그 놈들의 원래 인덱스에서 `-1`해줘야 한다.(`shift up`) 이게 pop(0)이 `O(N)`의 시간이 걸리는 이유이다!!

- 그럼 `pop(0)`이 모든 `pop` 중에서 가장 오랜 시간이 걸리겠네...? 헐.. 몰랐다.