---
title : 검색(Search)
tag: [프로그래밍]
categories: [프로그래밍]
math: true
comments: true
---

## 검색

- 정의: 저장되어 있는 자료들 중 원하는 항목을 찾는 과정. 탐색키(Search key)를 가지는 항목을 찾아내는 것.
- 검색 성공, 검색 실패로 나뉨.

---

### 검색 방식의 구분

- 내부 검색과 외부 검색 : 메인 메모리 내의 자료 / 보조 기억 장치에 있는 자료에 대해 검색
- 비교 검색과 계산 검색
  - 비교 검색: 검색 대상의 키를 비교하여 검색.(순차 검색, 이진 검색, 보간 검색)
  - 계산 검색: 계수적인 성질을 이용하여 계산을 통해 검색.(해싱)

---

### 순차 검색(Sequential Search)

#### HOW ? 

##### **① 정렬되어 있지 않은 자료에 대한 순차 검색**

- 첫 번째 항목부터 마지막 항목까지 순서대로 일치하는 항목이 있는지 비교함.
  - 검색 성공: 일치하는 항목이 발견되면 항목의 위치를 반환함.
  - 검색 실패: 마지막까지 일치하는 항목이 없으면 실패. 

##### **② 정렬되어있는 자료에 대한 순차 검색**

 - 이미 정렬되어 있으므로, 항목값이 찾는 키 값보다 크면 바로 검색 실패.
   	- ex) [1 3 5 7 9]에서, 6을 찾고자 할 때, 1 - 3 - 5 - 7까지 가서 7 > 6임을 확인하는 순간 검색 실패.

#### 복잡도

- 공간복잡도 : O(N)
- 시간복잡도 : O(N)

---

### 색인순차검색(Index Sequential Search)

#### HOW?

 - 정렬되어 있는 자료에 대하여, 인덱스 테이블을 추가로 사용하여 순차 탐색을 수행하는 방법.

 - 인덱스 테이블 

    - 일정한 간격으로 배치되어있는 항목 값들을 저장한 테이블

    - 자료가 [1, 2, 8, 9, 11, 19, 29] (**정렬되어 있음에 유의!**)이고, 인덱스 테이블의 크기가 3이면

       - 인덱스는 0번째, 3번째, 6번째 인덱스가 저장되며

       - 각각 [1], [9], [29]가 key 값으로 저장됨.

         ```
         Original Array : [1, 2, 8, 9, 11, 19, 29]
         Indexes : 		 [0, 1, 2, 3, 4, 5, 6]
         
         if index table == 3, then index table looks like
         [index , key]
         [[0, 1],
         [3, 9],
         [6, 29]]
         ```

- 찾고자 하는 키 값이 인덱스 테이블의 i 번째 키값과 (i+1)번째 키값 사이에 있다면, 해당 범위에 대해서만 순차검색을 진행하는 방식!
- 검색 성능
  - 인덱스 테이블의 크기에 따라 결정된다.
    - 인덱스 테이블 크기가 작다 → 인덱스 간격이 크다 → 검색해야할 범위가 넓다.
    - 인덱스 테이블 크기가 크다 → 인덱스 간격이 작다 → 검색해야할 범위가 작다. (단, 인덱스 테이블을 검색하는 시간이 길어진다.)

#### 복잡도

- 공간복잡도 : 자료가 N개, 인덱스가 M개 라면 **O(N+M)**
- 시간복잡도 : **O(M+N/M)**

---

### 이진 검색(Binary Search)

#### HOW?

- 정렬되어 있는 데이터에 대하여, 중간에 위치한 항목을 기준으로 데이터를 두 부분으로 나누어 가면서 특정 항목을 찾는 방법.

 - 분할 및 정복(Divide & Conquer) 전략을 이용한 방법.
   	- 찾으려는 값 > 현재 위치의 항목 값 : 현재 위치의 오른쪽 부분에 대해서 비교함. (분할) - 찾으면 (정복)
      	- 찾으려는 값 < 현재 위치의 항목 값 : 현재 위치의 왼쪽 부분에 대해서 비교함. (분할) - 찾으면 (정복)

#### 복잡도

 - 공간복잡도 : N개의 메모리공간만을 사용하므로, **O(N)**
 - 시간복잡도 : N개 항목에 대해 매 회 1/2로 나누므로, **O(logN)**
    - ex) 8개($$=2^3$$)의 항목에 대해 이진 검색을 해보자.
    - [1, 2, 3, 4, 5, 6, 7, 8] , 1을 찾자.
       - 중간에 위치한 항목은 [4]나 [5]. 반올림해서 [5]라고 하자.
       - 1회 : 1은 5보다 작다. 따라서 5의 왼쪽 부분에 대해서만 비교 **(분할)**
       - 2회 : 중간값 [3]. 1은 3보다 작다. 따라서 3의 왼쪽 부분에 대해서만 비교. **(분할)**
       - 3회 : 중간값 [2]. 1은 2보다 작다. 따라서 2의 왼쪽 부분에 대해서만 비교. → 1을 찾았다 ! **(정복)**
         - 가장 극단 값을 찾는 경우에도, $$log(2^3)$$ 즉 최대 3회에서 종료됨을 알 수 있다.

---

### 보간검색(Interpolation Search)

#### HOW?

 - 정렬되어 있는 데이터에 대하여, 찾고자 하는 항목의 위치를 짐작(예측)하여 탐색하는 방법.

 - 이진 검색과 유사하나, 자료를 균등하게 분할하지 않는다는 점에서 차이가 있다.

 - 찾고자 하는 항목과 그 위치가 비례 관계에 있다고 가정한다.

   	- 예를 들어, [0, 1, 2, 3, 4, 5, 6, 7]에서 7을 찾는 경우, 7의 위치가 대략 7번째에 있을 것이라고 가정하는 것!
      	- 따라서, 위와 같은 Uniformly Distributed 된 자료에 아주 적합하다.

 - 보간 검색의 위치 

    - **idx = (key - list[low]) / (list[high] - list[low]) * (high - low) + low**

   ```
   idx = (key - list[low]) / (list[high] - list[low]) * (high - low) + low
   
   if Array = [1, 12, 28, 39, 41, 59, 69],
   and if we want to find 41,
   then
   idx = (41 - 1) / (69 - 1) * (6 - 0) + 0 = 3.52941...
   round up idx = 4
   
   Array[4] = 41
   
   Interpolation Search Successed!
   ```

#### 복잡도

- 공간복잡도 : O(N)
- 시간복잡도 : 평균적으로 O(logN), 최악의 경우 O(N) → 짐작하는 알고리즘이기 때문에 최악의 경우 모든 자료값을 다 비교해야할 수도 있다.

---

