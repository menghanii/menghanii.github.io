정렬이란, 순서없이 배열되어 있는 자료를 오름차순 또는 내림차순과 같이 특정 순서대로 재배열하는 것을 의미합니다. 정렬을 알기 위해서는 먼저 정렬과 관련된 용어를 익혀야 하는데, ① 레코드 와 ② 정렬 키(sort key) 입니다.  레코드는 정렬시켜야될 대상을 의미하며, 레코드는 여러 개의 필드(field)로 이루어져 있습니다. 예를 들어, 레코드를 우리 학과의 학생들로 생각한다면, 필드는 '학번', '나이', '키', '연락처' 등이 있을 것입니다. 정렬 키는 정렬에 사용되는 필드를 의미합니다. 만약 예시에서, 학번에 따라 학생을 정렬하는 경우, '학번'이 정렬 키가 되겠죠?

다음으로 정렬 방식을 구분해볼텐데요. 정렬 방식에는 크게 '정렬 장소'와 '실행 방법'에 따른 방식들이 있습니다. 정렬 장소에 따른 정렬방식에는, 내부정렬과 외부정렬이 있습니다. 내부 정렬은 모든 데이터를 메인 메모리 내부에서 정렬하는 것을 의미하고, 외부정렬은 외부 기억 장치에서 레코드를 정렬하는 것을 의미합니다. 더 중요한 건 '실행 방법'에 따른 정렬방식의 분류인데요. ①비교식 정렬은 비교하고자 하는 각 키 값들을 한 번에 두 개씩 비교하여 교환하는 방식입니다. 만약 오름차순 정렬을 하고 싶은데, '3, 1, 2, 5, 4' 가 주어져 있다면, 3과 1을 비교해서 교환하고, 3과 2를 비교해서 교환하고, ... 이런 방식으로 정렬하는 것이 비교식 정렬의 예가 되겠습니다. ②분산식 정렬은 조금 다른데요. 특정 key 값을 기준으로, 자료를 여러 개의 부분집합으로 분해하고 각 부분 집합을 정렬함으로써 전체를 정렬하는 방식을 의미합니다.

이제 정렬의 기본 개념을 익혔으니, 다양한 정렬에 대해 알아보겠습니다.

### 선택 정렬(Selection Sort)

선택 정렬은, 전체 항목들 중에서 기준 위치에 맞는 항목을 선택하여 자리를 교환하는 방식으로 이루어지는 정렬입니다. [5 3 8 4 9 1 6 2 7]의 정렬되지 않은 리스트가 있습니다. 이에 대해 오름차순 정렬을 수행하는 경우, 먼저 가장 왼쪽에 있는 5를 교환할 건데요. 최솟값인 1을 찾고 이를 5와 교환합니다. 다음으로 두 번째 위치에 있는 3을 교환합니다.최솟값인 2를 찾아 3과 교환하고, .... 마찬가지로 최종 정렬을 마칠 때까지 해당 위치의 숫자와 최솟값이 되는 항목을 찾아 교환해주는 정렬 방식입니다.

선택 정렬은 N개의 자료에 대해 N개의 메모리 공간을 사용하므로, 공간복잡도는 $$O(N)$$입니다. 한편, 시간 복잡도는 $$O(N^2)$$ 인데요. 5를 바꿀 때, 최솟값 1을 찾기 위해 3, 8, 4, 9, 1, 6, 2, 7을 비교해야 합니다. 따라서 N개의 자료에서 첫 번쨰 교환은 (N-1), 두 번째 교환은 (N-2), ....,  1까지의 비교 횟수가 필요합니다. 따라서 n(n-1)/2 번의 비교가 일어나므로 시간 복잡도는 $$O(N^2)$$ 가 됩니다.

---

### 버블정렬(Bubble Sort)

버블 정렬은, 인접한 2개의 항목을 비교하여 순서대로 서로 교환하는 과정을, 전체 자료에 대해서 수행하는 정렬 방식입니다. 한 번의 스캔이 완료되면 가장 큰 항목은 자료의 마지막 자리에 위치하며, 끝으로 이동한 항목을 제외하고 다시 스캔을 반복하는 방식입니다. 아까의 예와 같이, [5 3 8 4 9 1 6 2 7]이 있다고 합시다. 먼저 5와 3을 비교하여 더 큰 5가 오른쪽으로 가고, 5와 8을 비교하여 8이 더 크므로 그대로 둡니다. 8과 4를 비교하여 더 큰 8이 오른쪽으로 가고, .... 이런 방식으로 가장 큰 9가 최종적으로 가장 오른쪽으로 갑니다. 이것이 한 번의 스캔 과정입니다. 다음 번 스캔에서는 다시 처음부터 시작하여, 가장 큰 값이 있는 9 전까지를 스캔합니다. 따라서 8이 두 번째로 가장 오른쪽에 오게 됩니다.

버블 정렬은 N개의 자료에 대해 N개의 메모리 공간을 사용하므로 공간복잡도는 $$O(N)$$ 입니다. 한편 시간 복잡도는, 최선의 경우에는 자료가 모두 정렬되어 있는 경우이므로, 자리 교환은 없고 비교는 N개의 항목에 대해서 발생합니다. 최악의 경우에는 자료가 모두 역순으로 정렬되어 있는 경우이므로, N개의 항목에 대해 자리 교환과 비교가 모두 발생합니다. N개 항목들을 N개 항목들과 비교하므로, 시간복잡도는 $$O(N^2)$$ 입니다.

---

	### 삽입정렬(Insertion Sort)

삽입정렬은, 정렬되어있는 부분집합에 정렬하고자 하는 새로운 항목의 위치를 찾아서 삽입하는 정렬 방식입니다. 이는 정렬되어있지 않은 부분 집합의 항목을 하나씩 꺼내서, 이미 정렬된 집합의 마지막 원소부터 비교하면서 위치를 찾아서 삽입하는 방식인데요. 아까의 예를 다시 들어보겠습니다.

① [5 3 8 4 9 1 6 2 7]이 있습니다. 초기 상태에서 5는 정렬된 집합이고, 정렬되지 않은 부분집합 [3 8 4 9 1 6 2 7]에서 3부터 꺼내어, 정렬된 집합 5와 비교합니다. 3은 5보다 작으니 앞으로 가겠죠? 
② 정렬집합은 [3 5]가 되고, 정렬되지 않은 집합은 [8 4 9 1 6 2 7]이 됩니다. 8을 꺼내어 정렬된 집합의 마지막 원소 5와 비교합니다. 8이 크네요? 그럼 8은 그대로 둡니다. 
③ 정렬집합은 [3 5 8]이 되고, 정렬되지 않은 집합은 [4 9 1 6 2 7]이 됩니다. 4를 꺼내어 8과 비교합니다. 4가 작습니다. 그럼 5와 비교합니다. 4가 작습니다! 마지막으로 3과 비교합니다. 4가 크기 때문에 4를 3과 5 사이에 넣어줍니다.
④ 정렬집합은 [3 4 5 8]이 되고, 정렬되지 않은 집합은 [9 1 6 2 7]이 됩니다.
......
이렇게 정렬되지 않은 집합이 공집합이 될 때까지 정렬을 반복하면 됩니다.

삽입 정렬의 공간 복잡도는 N개의 자료에 대해 N개의 메모리 공간만을 활용하므로 $$O(N)$$ 입니다. 한편 시간복잡도는, 최선의 경우는 자료가 모두 정렬되어 있는 경우이고, 이 때 각 항목은 바로 자기 앞자리 항목과만 비교만 하면 되므로 시간 복잡도는 $$O(N)$$입니다. 그러나 최악의 경우는 자료가 모두 역순으로 정렬되어 있는 경우이고, 이 때는 모든 항목을 정렬된 집합의 모든 원소들과 비교해야하므로 시간 복잡도는 $$O(N^2)$$ 이 됩니다.

---

### 셸 정렬(Shell Sort)



