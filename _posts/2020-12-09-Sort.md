---
title : 정렬(Sort)
tag: [프로그래밍]
categories: [프로그래밍]
math: true
comments: true
---

정렬이란, 순서없이 배열되어 있는 자료를 오름차순 또는 내림차순과 같이 특정 순서대로 재배열하는 것을 의미합니다. 정렬을 알기 위해서는 먼저 정렬과 관련된 용어를 익혀야 하는데, ① 레코드 와 ② 정렬 키(sort key) 입니다.  
			① **레코드** : 정렬시켜야될 대상을 의미하며, 레코드는 여러 개의 필드(field)로 이루어져 있습니다. 예를 들어, 레코드를 우리 학과의 학생들로 생각한다면, 필드는 '학번', '나이', '키', '연락처' 등이 있을 것입니다. <br>
			② **정렬 키** : 정렬에 사용되는 필드를 의미합니다. 만약 예시에서, 학번에 따라 학생을 정렬하는 경우, '학번'이 정렬 키가 되겠죠?<br>

다음으로 정렬 방식을 구분해볼텐데요. 정렬 방식에는 크게 '정렬 장소'와 '실행 방법'에 따른 방식들이 있습니다. 정렬 장소에 따른 정렬방식에는, 내부정렬과 외부정렬이 있습니다. 내부 정렬은 모든 데이터를 메인 메모리 내부에서 정렬하는 것을 의미하고, 외부정렬은 외부 기억 장치에서 레코드를 정렬하는 것을 의미합니다. 더 중요한 건 '실행 방법'에 따른 정렬방식의 분류인데요. 
			① **비교식 정렬**은 비교하고자 하는 각 키 값들을 한 번에 두 개씩 비교하여 교환하는 방식입니다. 만약 오름차순 정렬을 하고 싶은데, '3, 1, 2, 5, 4' 가 주어져 있다면, 3과 1을 비교해서 교환하고, 3과 2를 비교해서 교환하고, ... 이런 방식으로 정렬하는 것이 비교식 정렬의 예가 되겠습니다. <br>
			② **분산식 정렬**은 조금 다른데요. 특정 key 값을 기준으로, 자료를 여러 개의 부분집합으로 분해하고 각 부분 집합을 정렬함으로써 전체를 정렬하는 방식을 의미합니다.<br>

이제 정렬의 기본 개념을 익혔으니, 다양한 정렬에 대해 알아보겠습니다.

### 선택 정렬(Selection Sort)

선택 정렬은, 전체 항목들 중에서 기준 위치에 맞는 항목을 선택하여 자리를 교환하는 방식으로 이루어지는 정렬입니다. [5 3 8 4 9 1 6 2 7]의 정렬되지 않은 리스트가 있습니다. 이에 대해 오름차순 정렬을 수행하는 경우, 먼저 가장 왼쪽에 있는 5를 교환할 건데요. 최솟값인 1을 찾고 이를 5와 교환합니다. 다음으로 두 번째 위치에 있는 3을 교환합니다.최솟값인 2를 찾아 3과 교환하고, .... 마찬가지로 최종 정렬을 마칠 때까지 해당 위치의 숫자와 최솟값이 되는 항목을 찾아 교환해주는 정렬 방식입니다.

선택 정렬은 N개의 자료에 대해 N개의 메모리 공간을 사용하므로, 공간복잡도는 $$O(N)$$입니다. 한편, 시간 복잡도는 $$O(N^2)$$ 인데요. 5를 바꿀 때, 최솟값 1을 찾기 위해 3, 8, 4, 9, 1, 6, 2, 7을 비교해야 합니다. 따라서 N개의 자료에서 첫 번쨰 교환은 (N-1), 두 번째 교환은 (N-2), ....,  1까지의 비교 횟수가 필요합니다. 따라서 n(n-1)/2 번의 비교가 일어나므로 시간 복잡도는 $$O(N^2)$$ 가 됩니다.

---

### 버블정렬(Bubble Sort)

버블 정렬은, 인접한 2개의 항목을 비교하여 순서대로 서로 교환하는 과정을, 전체 자료에 대해서 수행하는 정렬 방식입니다. 한 번의 스캔이 완료되면 가장 큰 항목은 자료의 마지막 자리에 위치하며, 끝으로 이동한 항목을 제외하고 다시 스캔을 반복하는 방식입니다. 아까의 예와 같이, [5 3 8 4 9 1 6 2 7]이 있다고 합시다. 먼저 5와 3을 비교하여 더 큰 5가 오른쪽으로 가고, 5와 8을 비교하여 8이 더 크므로 그대로 둡니다. 8과 4를 비교하여 더 큰 8이 오른쪽으로 가고, .... 이런 방식으로 가장 큰 9가 최종적으로 가장 오른쪽으로 갑니다. 이것이 한 번의 스캔 과정입니다. 다음 번 스캔에서는 다시 처음부터 시작하여, 가장 큰 값이 있는 9 전까지를 스캔합니다. 따라서 8이 두 번째로 가장 오른쪽에 오게 됩니다.

버블 정렬은 N개의 자료에 대해 N개의 메모리 공간을 사용하므로 공간복잡도는 $$O(N)$$ 입니다. 한편 시간 복잡도는, 최선의 경우에는 자료가 모두 정렬되어 있는 경우이므로, 자리 교환은 없고 비교는 N개의 항목에 대해서 발생합니다. 최악의 경우에는 자료가 모두 역순으로 정렬되어 있는 경우이므로, N개의 항목에 대해 자리 교환과 비교가 모두 발생합니다. N개 항목들을 N개 항목들과 비교하므로, 시간복잡도는 $$O(N^2)$$ 입니다.

---

### 삽입정렬(Insertion Sort)

삽입정렬은, 정렬되어있는 부분집합에 정렬하고자 하는 새로운 항목의 위치를 찾아서 삽입하는 정렬 방식입니다. 이는 정렬되어있지 않은 부분 집합의 항목을 하나씩 꺼내서, 이미 정렬된 집합의 마지막 원소부터 비교하면서 위치를 찾아서 삽입하는 방식인데요. 아까의 예를 다시 들어보겠습니다.

① [5 3 8 4 9 1 6 2 7]이 있습니다. 초기 상태에서 5는 정렬된 집합이고, 정렬되지 않은 부분집합 [3 8 4 9 1 6 2 7]에서 3부터 꺼내어, 정렬된 집합 5와 비교합니다. 3은 5보다 작으니 앞으로 가겠죠? <br>
② 정렬집합은 [3 5]가 되고, 정렬되지 않은 집합은 [8 4 9 1 6 2 7]이 됩니다. 8을 꺼내어 정렬된 집합의 마지막 원소 5와 비교합니다. 8이 크네요? 그럼 8은 그대로 둡니다. <br>
③ 정렬집합은 [3 5 8]이 되고, 정렬되지 않은 집합은 [4 9 1 6 2 7]이 됩니다. 4를 꺼내어 8과 비교합니다. 4가 작습니다. 그럼 5와 비교합니다. 4가 작습니다! 마지막으로 3과 비교합니다. 4가 크기 때문에 4를 3과 5 사이에 넣어줍니다.<br>
④ 정렬집합은 [3 4 5 8]이 되고, 정렬되지 않은 집합은 [9 1 6 2 7]이 됩니다.<br>
......<br>
이렇게 정렬되지 않은 집합이 공집합이 될 때까지 정렬을 반복하면 됩니다.

삽입 정렬의 공간 복잡도는 N개의 자료에 대해 N개의 메모리 공간만을 활용하므로 $$O(N)$$ 입니다. 한편 시간복잡도는, 최선의 경우는 자료가 모두 정렬되어 있는 경우이고, 이 때 각 항목은 바로 자기 앞자리 항목과만 비교만 하면 되므로 시간 복잡도는 $$O(N)$$입니다. 그러나 최악의 경우는 자료가 모두 역순으로 정렬되어 있는 경우이고, 이 때는 모든 항목을 정렬된 집합의 모든 원소들과 비교해야하므로 시간 복잡도는 $$O(N^2)$$ 이 됩니다.

---

### 셸 정렬(Shell Sort)

셸 정렬은, 일정한 **간격**으로 떨어져 있는 자료들끼리 부분집합을 구성하여, 각 부분집합에 있는 항목들에 대해 삽입 정렬(Insertion Sort) 수행을 반복하여 전체를 정렬하는 방식입니다.

**간격**에 따라 나뉘어진 각각의 부분집합을 삽입정렬한 뒤, 간격을 반으로 줄여가면서 간격이 1이 될때까지 반복합니다. 간격은 홀수로 하는 것이 좋으며, 간격을 절반으로 줄일 때는 홀수값이 나올 수 있게 해줍니다. 

[5 3 8 4 9 1 6 2 7] 이 있을 때,

① 최초 간격을 5로 설정했다면, {5, 1}, {3, 6}, {8, 2}, {4, 7}, {9} 총 5개의 부분집합들이 구성됩니다. 이 부분집합들 각각을 삽입 정렬해줍시다. → {1, 5}, {3, 6}, {2, 8}, {4, 7}, {9} → 합치게 되면, [1, 3, 2, 4, 9, 5, 6, 8, 7]이 됩니다. <br> ② 다음으로 간격을 (5//2)+1 = 3으로 줄여봅시다. {1, 4, 6}, {3, 9, 8}, {2, 5, 7} 3개의 부분집합이 나옵니다. 이들을 또 삽입정렬해봅시다. {1, 4, 6}, {3, 8, 9}, {2, 5, 7} → 합치면 [1, 3, 2, 4, 8, 5, 6, 9, 7]이 됩니다.<br>
③ (3//2) = 1로 줄여볼까요? 1로 줄이면 {1, 3, 2, 4, 8, 5, 6, 9, 7}의 부분집합 1개가 나옵니다. 이 리스트를 삽입정렬하면, 최종적으로 {1, 2, 3, 4, 5, 6, 7, 8, 9}가 됩니다.

셸 정렬은 N개의 항목에 대해 N개의 메모리공간만을 사용하므로 공간복잡도는 O(N)입니다. 한편, 시간복잡도는 처음 자료 상태와는 상관없이 간격 값에 의해 비교 횟수가 결정되므로, 일반적인 시간 복잡도는 O(N^2) 보다 작고, 최악의 경우에는 O(N^2)가 됩니다.

---

### 퀵 정렬(Quick Sort)

퀵 정렬은, 특정 기준 값(Pivot이라고 합니다.) 을 중심으로 왼쪽 부분 집합, 오른쪽 부분 집합을 분할하여 분할 및 정복(Divide and Conquer)을 수행하여 정렬하는 방식입니다.

전체 자료를 2개의 부분 집합으로 분할하고 → 각 부분 집합에 대해 재귀적으로 퀵 정렬을 호출합니다. 왼쪽 부분집합은 Pivot 보다 작은 항목들을, 오른쪽 부분집합은 Pivot보다 큰 항목들을 이동시킵니다.

[5 3 8 4 9 1 6 2 7]에서,

5를 피벗으로 선택해봅시다. 'LOW'는 피벗보다 작은 값을 가리키는 화살표, 'HIGH'는 피벗보다 큰 값을 가리키는 화살표입니다. LOW는 왼쪽에서부터, HIGH는 오른쪽에서부터 각각 반대 방향으로 출발합니다. LOW는 피벗보다 큰 항목을 만날때까지, HIGH는 피벗보다 작은 항목을 만날때까지 이동합니다.

① LOW는 8에서 멈추고, HIGH는 2에서 멈추겠네요! 이 때 LOW와 HIGH의 항목을 서로 바꾸어줍니다. → [5 3 2 4 9 1 6 8 7] <br>
② 다음으로 LOW는 9에서, HIGH는 1에서 멈추겠죠. 또 바꿔줍니다. → [5 3 2 4 1 9 6 8 7] <br>
③ 이제 LOW가 오른쪽으로 가고, HIGH가 왼쪽으로 가면 두 화살표가 역전됩니다. 이 때 BREAK! <br>
④ 피벗을 최종 HIGH, 즉 1과 위치 교환을 해줍니다. [1 3 2 4 <<5>> 9 6 8 7] <br>
⑤ 그럼 피벗의 왼쪽은 피벗보다 작은 집합, 오른쪽은 피벗보다 큰 집합이 되겠죠? 이 두 집합에 대해서 다시 퀵 정렬을 수행합니다! <br>
⑥ 왼쪽 집합만 한 번 해보겠습니다. 1을 피벗으로 하면, 피벗보다 작은 HIGH가 없기 때문에 그대로 {1, 3, 2, 4}가 됩니다. 그럼 1의 오른쪽 집합을 정렬해야겠네요? <br>
⑦ {3, 2, 4}를 정렬해봅시다. 3을 피벗으로 LOW는 2, HIGH는 4입니다. LOW 와 HIGH를 한 번 더 움직이면 역전되죠? 이 때의 HIGH값과 피벗인 3을 바꿔줍니다. → {2, 3, 4} <br>
⑧ 3의 왼쪽 집합인 {2}와 오른쪽 집합인 {4}를 정렬해줍니다. 그대로겠네요! 그럼 5의 왼쪽집합에 대한 정렬은 종료되었습니다.

퀵 정렬의 공간복잡도는 N개의 메모리 공간만을 사용하기 때문에 O(N)입니다. 한편 시간복잡도는, <br>

① 최선의 경우 : 자료를 균등 분할할 수 있는 경우. 수행 단계의 횟수가 최소가 되어 시간복잡도는 O(NlogN)이 됩니다. <br>
② 최악의 경우 : 이미 완전히 자료가 정렬된 경우. 분할이 1:(N-1)로 치우쳐 수행단계 횟수가 최대가 되므로 이 때 시간복잡도는 O(N^2) 입니다.

---

### 병합정렬(Merge Sort)

병합 정렬도 분할 및 정복을 사용하는 대표적인 정렬 방식인데요. 여러 개의 정렬된 자료의 집합을 병합하여 한 개의 정렬된 집합으로 만드는 정렬 방식입니다.

병합 정렬에는 2-way 병합과 n-way 병합이 있는데요. 각각 2개 혹은 n개의 정렬된 자료의 집합을 결합하여 하나의 정렬된 결과 집합을 생성하는 방식입니다.

![image](https://user-images.githubusercontent.com/37925813/101658796-b6193280-3a88-11eb-9a0e-384eba7c8d34.png)

<수업 자료에서 가져온 이미지입니다>

병합정렬은 말로 설명하기 너무 복잡하고 길어질 것 같아서, 이미지로 대체하겠습니다 ㅎㅎ. 자료를 분할한 후에, 병합하는 과정에서 정렬이 이루어지게 되는데요. 이 때 병합을 위한 리스트가 생성되는데요. 만약 {10, 27}과 {12, 20}을 병합하는 경우에, 두 집합의 맨 왼쪽 원소부터 비교해서 새 리스트에 넣어줍니다. 10과 12를 비교해서 {10}을, 27과 12를 비교해서 {10, 12}, 27과 20을 비교해서 {10, 12, 20}, 그리고 남은 27을 넣어 {10, 12, 20, 27}을 만드는 방식입니다.

병합정렬의 공간 복잡도는 각 단계에서 새로 병합하여 만든 부분집합을 저장할 공간이 추가적으로 필요합니다. 또한 시간 복잡도는 N개의 원소를 2개로 분할하기 위해 logN회의 분할 단계가 필요하고, 병합하는 단계에서 최대 N회의 비교연산이 수행되므로 O(NlogN)의 시간복잡도를 갖습니다.

---

### 기수정렬(Radix Sort)
