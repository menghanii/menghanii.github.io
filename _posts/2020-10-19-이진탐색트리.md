# 이진탐색트리

---

## 탐색트리(Search Tree)

- 데이터의 탐색/삽입/삭제/변경 연산을 수행하기 위해 순차리스트 대신 트리 형태의 자료구조를 사용하면, 시간 복잡도가 감소할 수 있다.
  - 순차리스트 : O(N) 의 시간복잡도를 가짐.
  - 이진 탐색
    - 정의: **정렬**되어 있는 데이터에 대하여, **중간**에 위치한 항목을 기준으로 데이터를 **두 부분**으로 나누어가며 특정 항목을 찾는 탐색 방법

---

## 이진탐색의 알고리즘

1) 찾으려고 하는 값(Searching, S)과 자료의 가운데(Center, C)에 위치해 있는 항목을 비교한다.

2) 만약, S > C 이면, C의 오른쪽 부분에 대해 1)을 실행한다.

3) 만약, S < C 이면, C의 왼쪽 부분에 대해서 1)을 실행한다.

4) 만약 S == C 이면 검색 성공!

5) 원하는 값을 찾을 때까지 반복적으로 수행함. 

---

### 이진탐색의 예 : 66을 찾아보자.

[5, 8, 10, 15, 20, 25, 30, 40, 50, 54, 66, 69, 83, 86, 90]

STEP 1 : 가운데를 본다. (C = 40), S > C이므로 왼쪽 날리고 오른쪽만 본다.

STEP 2 : 가운데를 본다.(C = 69), S < C 이므로 오른쪽 날리고 왼쪽만 본다.

STEP 3 : 가운데를 본다.(C = 54), S > C 이므로 왼쪽 날리고 오른쪽만 본다.

STEP 4 : 66 나왔다!

---

### 이진탐색의 특징

- 반드시 정렬되어 있는 자료에 대해서만 적용할 수 있다. → 원본 데이터가 정렬되어 있어야 한다는 한계가 존재함.
  - 만약 원본데이터가 정렬 안되어 있다면, 정렬해주고 이진탐색해야함. → 만약 정렬 알고리즘이 오히려 오래 걸린다면 쓸 수 없음.
- **분할 및 정복(Divide & Conquer)** 전략을 이용한 방법이다.
  - 검색할 범위를 절반으로 줄인 뒤(divide), 그 안에서 처리 과정(conquer)을 반복적으로 수행한다.
  - 검색 방식 자체가 재귀적으로 동작한다.
- 정렬되어 있는 입력 데이터의 크기가 N일 때, 시간복잡도는 **O(logN)** 이다.
  - 왜 O(logN)일까?
  - 1번 step에서는 N개를 봄. → 2번 step에서는 N/2개를 봄. → 3번 step에서는 N/4 → ... → k번 step 에서는 N/2**(k-1) 개를 봄.
  - k번째에 검색이 끝났다고 하자. 즉, N/2**(k-1) = 1 이 되는 것.
  - 그 때의 k = logN이 됨.

---

## 이진탐색트리(BST; Binary Search Tree)

- 이진탐색방법을 트리에 적용한 자료 구조.
- 이진 탐색 트리는 **이진트리**이다.
- 이진 탐색 트리는 **탐색 트리**이다.
- 이진 탐색 트리는 **이진 탐색**을 한다.
- 왜 만드냐? **탐색/삽입/삭제**를 빠르고 용이하게 하기 위해!

---

### 이진 탐색 트리의 정의

1) 모든 노드는 서로 다른 유일한 항목값을 가진다.

2) 왼쪽 서브트리의 항목들은 루트노드의 항목보다 작다.

3) 오른쪽 서브트리의 항목들은 루트 노드의 항목보다 크다.

4) 왼쪽과 오른쪽 서브트리도 이진탐색트리이다.(재귀적 정의)

![upload-image]({{ "/assets/img/images/20201019/image-20201019153528333.png" | relative_url }})

---

### 이진탐색트리에서의 탐색

1) S 와 현재 트리의 루트 노드의 항목을 비교한다.(R)

2) S > R 이라면, R의 오른쪽 서브 트리에 대해 1)을 실행한다.

3) S < R 이라면, R의 왼쪽 서브 트리에 대해 1)을 실행한다.

4) S == R 이라면 검색이 성공한 것이다.

![upload-image]({{ "/assets/img/images/20201019/image-20201019154131662.png" | relative_url }})

---

### 이진탐색트리에서의 삽입

- 탐색 연산과 거의 동일한 방식으로 새로운 항목값(노드)을 삽입한다.
- 검색을 실패한 위치에 노드를 추가하면 된다.